Consider the following problem (tweeted [\@ChShersh](https://twitter.com/ChShersh) on 2025/06/18 and rephrased by me):

> You have before you a button that each time when pressed manifests a value sampled uniformly at random from between \$0 and \$100,000. The first 9 times you press it, you can either destroy the button and keep the money or destroy the money and keep the button\; after the button is pressed 10 times it self-destructs.
>
> With what strategy do you optimize the expected amount of money with which you walk away?

This is a particularly simple case of the general [optimal stopping problem](https://en.wikipedia.org/wiki/Optimal_stopping) and can be solved by the standard technique [backward induction](https://en.wikipedia.org/wiki/Backward_induction).

Here we demonstrate that backward induction is just the fixed point of an obvious "bootstrapping" function on the space of strategies by implementing this bootstrapping function typeclass-generically in Haskell and applying `Data.Function.fix` to it to obtain optimal strategies for the following three classical optimal stopping problems:
- the problem quoted above
- [the secretary problem](https://en.wikipedia.org/wiki/Secretary_problem)
- [the coin tossing problem](https://en.wikipedia.org/wiki/Optimal_stopping#Coin_tossing))

The relevant code, in [src/OptStop.hs](https://github.com/thesnakefromthelemma/tsftl-lab/blob/master/opt-stop/src/OptStop.hs), is extensively commented and meant to be read in-editor and/or using the documentation generated by Haddock.

There was some initial motivation to implement an interactive component in [app/Main.hs](https://github.com/thesnakefromthelemma/tsftl-lab/blob/master/opt-stop/app/Main.hs), but I am not currently working on this.